{"version":3,"file":"standalone.min.js","sources":["../node_modules/lite-url/dist/lite-url.min.js","../src/utils.js","../src/regexify.js","../src/components.js"],"sourcesContent":["/**\n * lite-url - Small, JS lib that uses regex for parsing a URL into it's component parts.\n * @version v1.0.5\n * @link https://github.com/sadams/lite-url\n * @license BSD-3-Clause\n */\n(function(){\"use strict\";function r(r,n,t){var e=r.split(n),o=e.shift();return t(o,e.join(n))}function n(n){var t={hash:\"\",host:\"\",hostname:\"\",origin:\"\",pathname:\"\",protocol:\"\",search:\"\",password:\"\",username:\"\",port:\"\"};return r(n,\"#\",function(n,e){e&&(t.hash=e?\"#\"+e:\"\"),r(n,\"?\",function(n,e){e&&(t.search=\"?\"+e),n&&r(n,\"//\",function(n,e){t.protocol=n,r(e,\"/\",function(n,e){t.pathname=\"/\"+(e||\"\"),(t.protocol||n)&&(t.origin=t.protocol+\"//\"+n),r(n,\"@\",function(n,e){if(e){var o=n.split(\":\");t.username=o[0],t.password=o[1]}else e=n;t.host=e,r(e,\":\",function(r,n){t.hostname=r,n&&(t.port=n)})})})})})}),t.href=t.origin+t.pathname+t.search+t.hash,t}function t(r){var n={},t=r.search;if(t){t=t.replace(new RegExp(\"\\\\?\"),\"\");var e=t.split(\"&\");for(var o in e)if(e.hasOwnProperty(o)&&e[o]){var i=e[o].split(\"=\");n[i[0]]=i[1]}}return n}function e(r){var e=i[r];return\"undefined\"!=typeof e?e:(e=n(r),e.params=t(e),i[r]=e,e)}var o=this,i={};return e.changeQueryParser=function(r){t=r},\"undefined\"!=typeof exports?(\"undefined\"!=typeof module&&module.exports&&(exports=module.exports=e),exports.liteURL=e):o.liteURL=e,e}).call(this);\n","import LiteURL from 'lite-url';\nimport regexify from './regexify';\n\nconst PATH_EXTRACTION_R = /:[^/?#()]*/g;\n\nconst isString = x => typeof x === 'string';\n\nexport function extractParamsFromPath(path) {\n    return isString(path)\n        ? (path.match(PATH_EXTRACTION_R) || [])\n              // remove the leading colon\n              .map(param => param.slice(1))\n        : [];\n}\n\nexport function getRouteParamsForURL(route, url) {\n    if (!route.params.length) return {};\n\n    const result = url.match(route.test) || [];\n\n    if (result.length) result.shift(); // discard the catchall result\n\n    return result.reduce((params, result, index) => {\n        return (params[route.params[index]] = result), params;\n    }, {});\n}\n\nexport function processRoute(route) {\n    return Object.assign({}, route, {\n        params: extractParamsFromPath(route.path),\n        test: isString(route.path) ? regexify(route.path) : route.path,\n    });\n}\n\nexport function valid(validator, url) {\n    if (validator instanceof RegExp) {\n        return validator.test(url);\n    } else if (validator instanceof Function) {\n        return validator(url);\n    }\n}\n\nexport function getRedirectUrl(redirect, originalUrl) {\n    /** Fully-resolved, no work to be done here. */\n    if (redirect.includes('://')) return redirect;\n\n    const { protocol, host } = new LiteURL(originalUrl);\n\n    /**\n     * Reconstruct a full URL based on the original with the path\n     * switched to the given redirect.\n     */\n    return `${protocol}//${host}${redirect}`;\n}\n\nexport function findRoute(routes, url) {\n    const route = routes.find(route => valid(route.test, url));\n\n    if (route) {\n        if (route.redirect)\n            return findRoute(routes, getRedirectUrl(route.redirect, url));\n        else return { route, url };\n    }\n\n    throw new Error(\n        `No valid routes were found for URL ${url}. Did you forget to define a fallback \"*\" path?`,\n    );\n}\n\nexport function getDisplayName(Component) {\n    return Component.displayName || Component.name || 'Component';\n}\n\nexport function parseUrl(url) {\n    const parsed = new LiteURL(url);\n\n    parsed.query = parsed.search\n        .slice(1)\n        .split('&')\n        .reduce((params, pair) => {\n            if (pair) {\n                const idx = pair.indexOf('=');\n\n                params[pair.slice(0, idx)] = pair.slice(idx + 1);\n            }\n\n            return params;\n        }, {});\n\n    return parsed;\n}\n\n/**\n * Generates an object containing a window.location facsimile\n * for the given URL, any parsed route parameters, and the\n * route itself.\n *\n * @returns {Object} RoutingContext\n */\nexport function createRouteContext(route, url) {\n    return {\n        location: parseUrl(url),\n        params: getRouteParamsForURL(route, url),\n        route,\n    };\n}\n\n/**\n * Given a set of route definitions and a fully-resolved URL,\n * return a routing context object.\n *\n * If a redirect should be performed, the \"redirect\" key will be\n * set with the appropriate URL.\n *\n * {\n *     location: object,\n *     params: object,\n *     route: object,\n *     redirect: string?,\n * }\n */\nexport function match(routes, url) {\n    const processedRoutes = routes.map(processRoute);\n\n    /**\n     * If a redirect occurred, finalUrl may be different from\n     * the initial url.\n     */\n    const { route, url: finalUrl } = findRoute(processedRoutes, url);\n    const ret = Object.assign({}, createRouteContext(route, finalUrl));\n\n    if (finalUrl !== url) ret.redirect = finalUrl;\n\n    return ret;\n}\n\n/**\n * A client-side method for programmatically updating the routing state.\n *\n * Accepts a new url (absolute or relative) and an optional second boolean\n * parameter controlling if a new browser history entry should be created.\n *\n * If you want to change the routing state on server, just pass a new url to\n * the <Router> component.\n */\nexport function route(url, addNewHistoryEntry = true) {\n    history[addNewHistoryEntry ? 'pushState' : 'replaceState']({}, '', url);\n\n    // this is what triggers the routing to update\n    window.dispatchEvent(new Event('popstate'));\n}\n","export default function regexify(path) {\n    return new RegExp(\n        path\n            // escape regex reserved characters\n            .replace(/([/.?+])/g, '\\\\$1')\n\n            // handle wildcards: *\n            .replace(/[.]{0}[*](?![*])/g, '.*?\\/?')\n\n            // handle splats: **\n            .replace(/[/][.]{0}[*]{2}(?![*])/g, '.*?')\n\n            // handle query strings: ?foo=bar\n            .replace(/\\\\[?]/, '.*?\\\\?.*?')\n\n            // handle optional segments: (/bar)\n            .replace(/\\(([^)]+)\\)/g, '(?:$1)?')\n\n            // handle dynamic fragments: /:bar\n            .replace(/\\/:[^/()#?]*/g, '/([^/]*)')\n        + '$'\n    );\n}\n","import PropTypes from 'prop-types';\nimport React from 'react';\n\nimport {\n    createRouteContext,\n    findRoute,\n    getDisplayName,\n    processRoute,\n    route,\n    valid,\n} from './utils';\n\nconst { Provider, Consumer } = React.createContext();\nconst BROWSER = typeof window !== 'undefined';\nconst NOOP = function () { };\n\n/**\n * The gist of Buttermilk's router is that it acts like a controlled component when used\n * server-side (driven by `props.url`) and an uncontrolled one client-side (driven by the\n * value of `window.location.href` and intercepted navigation events.)\n *\n * In the browser, use either a <Link> component or the route() method to change routes.\n * The router will also automatically pick up popstate events caused by user-driven browser\n * navigation (forward, back buttons, etc.)\n */\nexport class Router extends React.Component {\n    static propTypes = {\n        /**\n         * Provide a spinner or something to look at while the promise\n         * is in flight if using async routes.\n         */\n        loadingComponent: PropTypes.oneOfType([\n            PropTypes.func,\n            PropTypes.string,\n        ]),\n\n        /**\n         * An optional app runtime component. Think of it like the \"shell\" of your\n         * app, so perhaps the outer container, nav bar, etc. You'll probably want to\n         * put any \"Provider\" type components here that are intended to wrap your\n         * whole application.\n         */\n        outerComponent: PropTypes.oneOfType([\n            PropTypes.func,\n            PropTypes.string,\n        ]),\n\n        routes: PropTypes.arrayOf(\n            PropTypes.shape({\n                /**\n                 * A RegExp, string, or function accepting the URL as\n                 * an argument and returning a boolean if valid.\n                 */\n                path: PropTypes.oneOfType([\n                    PropTypes.instanceOf(RegExp),\n                    PropTypes.string,\n                    PropTypes.func,\n                ]).isRequired,\n\n                /**\n                 * A string URL path to a different route. If this is given,\n                 * then \"render\" is not required.\n                 */\n                redirect: PropTypes.string,\n\n                /**\n                 * A function that returns one of the following:\n                 *\n                 * 1. JSX.\n                 * 2. A React component class.\n                 * 3. A promise resolving to JSX or a React component class.\n                 */\n                render: PropTypes.func,\n            }),\n        ).isRequired,\n\n        /**\n         * A hook for reacting to an impending route transition. Accepts a promise\n         * and will pause the route transition until the promise is resolved. Return\n         * false or reject a given promise to abort the routing update.\n         *\n         * Provides currentRouting and nextRouting as arguments.\n         */\n        routeWillChange: PropTypes.func,\n\n        /**\n         * A hook for reacting to a completed route transition. It might be used\n         * for synchronizing some global state if desired.\n         *\n         * Provides currentRouting and previousRouting as arguments.\n         */\n        routeDidChange: PropTypes.func,\n\n        /**\n         * A hook for synchronizing initial routing state.\n         *\n         * Providers initialRouting as an argument.\n         */\n        routerDidInitialize: PropTypes.func,\n\n        /**\n         * The initial URL to be used for processing, falls back to\n         * window.location.href for non-SSR. Required for environments without\n         * browser navigation eventing.\n         */\n        url: PropTypes.string,\n    };\n\n    static defaultProps = {\n        loadingComponent: 'div',\n        outerComponent: 'div',\n        routeDidChange: NOOP,\n        routeWillChange: NOOP,\n        routerDidInitialize: NOOP,\n        url: '',\n    };\n\n    static getURL = function () { return window.location.href; }\n\n    noFallbackWarningEmitted = false;\n    promise = null;\n\n    constructor(props, context) {\n        super(props, context);\n\n        if (!BROWSER && !props.url) {\n            throw new Error('props.url is required for non-browser environments');\n        }\n\n        const routes = this.processRoutes(props.routes);\n        const url = props.url || Router.getURL();\n\n        this.state = this.getStateUpdateForUrl(url, routes);\n\n        props.routerDidInitialize(createRouteContext(this.state.activeRoute, url));\n    }\n\n    /**\n     * In a browser setting, we only want to rely on browser navigation events\n     * to determine routing updates.\n     */\n    shouldRecompute(nextProps) {\n        return nextProps.routes !== this.props.routes\n            || ((nextProps.url !== this.state.url) && !BROWSER);\n    }\n\n    componentWillReceiveProps(nextProps) {\n        if (this.shouldRecompute(nextProps)) {\n            this.recomputeRoutingState(\n                BROWSER ? this.state.url : nextProps.url, nextProps.routes\n            );\n        }\n    }\n\n    componentDidMount() {\n        window.addEventListener('popstate', this.handleLocationChange);\n        window.addEventListener('hashchange', this.handleLocationChange);\n    }\n\n    componentWillUpdate() {\n        this.recomputeRoutingState\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('popstate', this.handleLocationChange);\n        window.removeEventListener('hashchange', this.handleLocationChange);\n    }\n\n    render() {\n        const contextValue = createRouteContext(this.state.activeRoute, this.state.url);\n\n        return (\n            <Provider value={contextValue}>\n                <this.props.outerComponent {...contextValue}>\n                    {this.renderChildren(this.state.children, contextValue)}\n                </this.props.outerComponent>\n            </Provider>\n        );\n    }\n\n    renderChildren(renderable, routingProps) {\n        if (renderable === null) {\n            return React.createElement(this.props.loadingComponent, routingProps);\n        } else if (!React.isValidElement(renderable)) {\n            return React.createElement(renderable, routingProps);\n        } else {\n            return renderable;\n        }\n    }\n\n    processChildren(unknown) {\n        if (unknown instanceof Promise) {\n            const instance = this;\n            instance.promise = unknown;\n            unknown.then(function handlePromiseResolution(result) {\n                /**\n                 * Is this promise still valid? If not, ignore the\n                 * resolution.\n                 */\n                if (instance.promise === this) {\n                    instance.setState({ children: result });\n                    this.promise = null;\n                }\n            }.bind(unknown), NOOP);\n\n            return null;\n        } else {\n            return unknown;\n        }\n    }\n\n    handleLocationChange = (/* event */) => {\n        const currentValue = createRouteContext(this.state.activeRoute, this.state.url);\n        const { route: nextRoute, url: nextUrl } = findRoute(this.state.routes, Router.getURL());\n        const nextValue = createRouteContext(nextRoute, nextUrl);\n        const result = this.props.routeWillChange(currentValue, nextValue);\n        const cb = () => this.props.routeDidChange(nextValue, currentValue);\n        const finish = () => this.recomputeRoutingState(nextUrl, this.state.routes, cb);\n\n        if (result === false) return;\n        else if (result instanceof Promise) result.then(finish, NOOP);\n        else finish();\n    }\n\n    recomputeRoutingState = (url, routes, cb) => {\n        this.setState(\n            this.getStateUpdateForUrl(\n                url, routes === this.state.routes ? routes : this.processRoutes(routes)\n            ), cb\n        );\n    }\n\n    processRoutes(routes) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (!this.noFallbackWarningEmitted && routes.every(route => route.path !== '*')) {\n                console.warn('no fallback route \"*\" was supplied. if a matching route is not found, the router will throw');\n                this.noFallbackWarning = true;\n            }\n        }\n\n        return routes.map(processRoute);\n    }\n\n    getStateUpdateForUrl(url, routes) {\n        const result = findRoute(routes, url);\n\n        return {\n            activeRoute: result.route,\n            children: this.processChildren(\n                result.route.render(\n                    createRouteContext(\n                        result.route, result.url\n                    )\n                )\n            ),\n            routes,\n            url: result.url,\n        };\n    }\n}\n\n/**\n * Compose it like this:\n *\n * <RoutingState>\n *   {({ location, params, route }) => {\n *      return <div>{location.pathname}</div>\n *   }}\n * </RoutingState>\n */\nexport const RoutingState = Consumer;\n\n/**\n * A polymorphic anchor link component. On click/tap/enter if the destination\n * matches a value route, the routing context will be modified without\n * reloading the page. Otherwise, it will act like a normal anchor link.\n *\n * If something other than an anchor tag is specified via props.as, a\n * [role=\"link\"] attribute will be added for basic assistive technology support.\n *\n * Adds [data-active] if the given href matches the active route.\n */\nexport class Link extends React.PureComponent {\n    static propTypes = {\n        /**\n         * An HTML tag name or valid ReactComponent class to be rendered. Must\n         * be compatible with React.createElement.\n         *\n         * Defaults to an anchor \"a\" tag.\n         */\n        as: PropTypes.oneOfType([\n            PropTypes.func,\n            PropTypes.string,\n        ]),\n\n        /**\n         * A valid relative or absolute URL string.\n         */\n        href: PropTypes.string.isRequired,\n\n        /**\n         * Any valid value of the anchor tag \"target\" attribute.\n         *\n         * See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-target\n         */\n        target: PropTypes.string,\n    };\n\n    static defaultProps = {\n        as: 'a',\n    };\n\n    render() {\n        return (\n            <Consumer>\n                {({ route }) => {\n                    return React.createElement(this.props.as, Object.assign({}, this.props, {\n                        'data-active': valid(route.test, this.props.href) ? '' : undefined,\n                        as: undefined,\n                        href: this.shouldRenderAnchorProps() ? this.props.href : undefined,\n                        role: this.shouldRenderRole() ? 'link' : undefined,\n                        onClick: this.handleNavigationIntent,\n                        onKeyDown: this.handleNavigationIntent,\n                        onTouchEnd: this.handleNavigationIntent,\n                        target: this.shouldRenderAnchorProps() ? this.props.target : undefined,\n                    }));\n                }}\n            </Consumer>\n        );\n    }\n\n    shouldRenderAnchorProps() {\n        return this.props.as === Link.defaultProps.as || typeof this.props.as !== 'string';\n    }\n\n    shouldRenderRole() {\n        return this.props.as !== Link.defaultProps.as;\n    }\n\n    handleNavigationIntent = e => {\n        if (e.type !== 'keydown' || (e.type === 'keydown' && (e.key === 'Enter' || e.key === 'Space'))) {\n            e.preventDefault();\n            e.stopPropagation();\n\n            if (e.metaKey || e.target.getAttribute('target') === '_blank') {\n                window.open(this.props.href);\n            } else {\n                route(this.props.href);\n            }\n        }\n    };\n}\n"],"names":["r","n","t","e","split","shift","join","hash","host","hostname","origin","pathname","protocol","search","password","username","port","o","href","replace","RegExp","hasOwnProperty","i","params","changeQueryParser","module","exports","call","this","PATH_EXTRACTION_R","isString","x","processRoute","route","Object","assign","path","match","param","slice","regexify","valid","validator","url","test","Function","findRoute","routes","find","redirect","originalUrl","includes","LiteURL","getRedirectUrl","Error","createRouteContext","parsed","query","reduce","pair","idx","indexOf","parseUrl","length","result","index","getRouteParamsForURL","addNewHistoryEntry","dispatchEvent","Event","React","createContext","Provider","Consumer","BROWSER","window","NOOP","Router","props","context","_this","processRoutes","getURL","state","getStateUpdateForUrl","routerDidInitialize","activeRoute","Component","nextProps","shouldRecompute","recomputeRoutingState","addEventListener","handleLocationChange","removeEventListener","contextValue","value","outerComponent","renderChildren","children","renderable","routingProps","createElement","loadingComponent","isValidElement","unknown","Promise","instance","promise","then","setState","bind","map","processChildren","render","propTypes","PropTypes","oneOfType","func","string","arrayOf","shape","instanceOf","isRequired","defaultProps","location","noFallbackWarningEmitted","currentValue","_this4","nextRoute","nextUrl","nextValue","routeWillChange","cb","routeDidChange","finish","RoutingState","Link","handleNavigationIntent","type","key","preventDefault","stopPropagation","metaKey","target","getAttribute","open","_this2","PureComponent","_this3","as","undefined","shouldRenderAnchorProps","shouldRenderRole","finalUrl","ret"],"mappings":"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"}