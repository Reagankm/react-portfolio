'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var PropTypes = _interopDefault(require('prop-types'));
var React = _interopDefault(require('react'));

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var liteUrl_min = createCommonjsModule(function (module, exports) {
/**
 * lite-url - Small, JS lib that uses regex for parsing a URL into it's component parts.
 * @version v1.0.5
 * @link https://github.com/sadams/lite-url
 * @license BSD-3-Clause
 */
(function () {
  function r(r, n, t) {
    var e = r.split(n),
        o = e.shift();return t(o, e.join(n));
  }function n(n) {
    var t = { hash: "", host: "", hostname: "", origin: "", pathname: "", protocol: "", search: "", password: "", username: "", port: "" };return r(n, "#", function (n, e) {
      e && (t.hash = e ? "#" + e : ""), r(n, "?", function (n, e) {
        e && (t.search = "?" + e), n && r(n, "//", function (n, e) {
          t.protocol = n, r(e, "/", function (n, e) {
            t.pathname = "/" + (e || ""), (t.protocol || n) && (t.origin = t.protocol + "//" + n), r(n, "@", function (n, e) {
              if (e) {
                var o = n.split(":");t.username = o[0], t.password = o[1];
              } else e = n;t.host = e, r(e, ":", function (r, n) {
                t.hostname = r, n && (t.port = n);
              });
            });
          });
        });
      });
    }), t.href = t.origin + t.pathname + t.search + t.hash, t;
  }function t(r) {
    var n = {},
        t = r.search;if (t) {
      t = t.replace(new RegExp("\\?"), "");var e = t.split("&");for (var o in e) {
        if (e.hasOwnProperty(o) && e[o]) {
          var i = e[o].split("=");n[i[0]] = i[1];
        }
      }
    }return n;
  }function e(r) {
    var e = i[r];return "undefined" != typeof e ? e : (e = n(r), e.params = t(e), i[r] = e, e);
  }var i = {};return e.changeQueryParser = function (r) {
    t = r;
  }, ("undefined" != 'object' && module.exports && (exports = module.exports = e), exports.liteURL = e), e;
}).call(this);
});
var liteUrl_min_1 = liteUrl_min.liteURL;

function regexify(path) {
    return new RegExp(path
    // escape regex reserved characters
    .replace(/([/.?+])/g, '\\$1')

    // handle wildcards: *
    .replace(/[.]{0}[*](?![*])/g, '.*?\/?')

    // handle splats: **
    .replace(/[/][.]{0}[*]{2}(?![*])/g, '.*?')

    // handle query strings: ?foo=bar
    .replace(/\\[?]/, '.*?\\?.*?')

    // handle optional segments: (/bar)
    .replace(/\(([^)]+)\)/g, '(?:$1)?')

    // handle dynamic fragments: /:bar
    .replace(/\/:[^/()#?]*/g, '/([^/]*)') + '$');
}

var PATH_EXTRACTION_R = /:[^/?#()]*/g;

var isString = function isString(x) {
    return typeof x === 'string';
};

function extractParamsFromPath(path) {
    return isString(path) ? (path.match(PATH_EXTRACTION_R) || []).
    // remove the leading colon
    map(function (param) {
        return param.slice(1);
    }) : [];
}

function getRouteParamsForURL(route, url) {
    if (!route.params.length) return {};

    var result = url.match(route.test) || [];

    if (result.length) result.shift(); // discard the catchall result

    return result.reduce(function (params, result, index) {
        return params[route.params[index]] = result, params;
    }, {});
}

function processRoute(route) {
    return Object.assign({}, route, {
        params: extractParamsFromPath(route.path),
        test: isString(route.path) ? regexify(route.path) : route.path
    });
}

function valid(validator, url) {
    if (validator instanceof RegExp) {
        return validator.test(url);
    } else if (validator instanceof Function) {
        return validator(url);
    }
}

function getRedirectUrl(redirect, originalUrl) {
    /** Fully-resolved, no work to be done here. */
    if (redirect.includes('://')) return redirect;

    var _ref = new liteUrl_min(originalUrl),
        protocol = _ref.protocol,
        host = _ref.host;

    /**
     * Reconstruct a full URL based on the original with the path
     * switched to the given redirect.
     */


    return protocol + '//' + host + redirect;
}

function findRoute(routes, url) {
    var route = routes.find(function (route) {
        return valid(route.test, url);
    });

    if (route) {
        if (route.redirect) return findRoute(routes, getRedirectUrl(route.redirect, url));else return { route: route, url: url };
    }

    throw new Error('No valid routes were found for URL ' + url + '. Did you forget to define a fallback "*" path?');
}

function parseUrl(url) {
    var parsed = new liteUrl_min(url);

    parsed.query = parsed.search.slice(1).split('&').reduce(function (params, pair) {
        if (pair) {
            var idx = pair.indexOf('=');

            params[pair.slice(0, idx)] = pair.slice(idx + 1);
        }

        return params;
    }, {});

    return parsed;
}

/**
 * Generates an object containing a window.location facsimile
 * for the given URL, any parsed route parameters, and the
 * route itself.
 *
 * @returns {Object} RoutingContext
 */
function createRouteContext(route, url) {
    return {
        location: parseUrl(url),
        params: getRouteParamsForURL(route, url),
        route: route
    };
}

/**
 * Given a set of route definitions and a fully-resolved URL,
 * return a routing context object.
 *
 * If a redirect should be performed, the "redirect" key will be
 * set with the appropriate URL.
 *
 * {
 *     location: object,
 *     params: object,
 *     route: object,
 *     redirect: string?,
 * }
 */
function match(routes, url) {
    var processedRoutes = routes.map(processRoute);

    /**
     * If a redirect occurred, finalUrl may be different from
     * the initial url.
     */

    var _findRoute = findRoute(processedRoutes, url),
        route = _findRoute.route,
        finalUrl = _findRoute.url;

    var ret = Object.assign({}, createRouteContext(route, finalUrl));

    if (finalUrl !== url) ret.redirect = finalUrl;

    return ret;
}

/**
 * A client-side method for programmatically updating the routing state.
 *
 * Accepts a new url (absolute or relative) and an optional second boolean
 * parameter controlling if a new browser history entry should be created.
 *
 * If you want to change the routing state on server, just pass a new url to
 * the <Router> component.
 */
function route(url) {
    var addNewHistoryEntry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    history[addNewHistoryEntry ? 'pushState' : 'replaceState']({}, '', url);

    // this is what triggers the routing to update
    window.dispatchEvent(new Event('popstate'));
}

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _React$createContext = React.createContext(),
    Provider = _React$createContext.Provider,
    Consumer = _React$createContext.Consumer;

var BROWSER = typeof window !== 'undefined';
var NOOP = function NOOP() {};

/**
 * The gist of Buttermilk's router is that it acts like a controlled component when used
 * server-side (driven by `props.url`) and an uncontrolled one client-side (driven by the
 * value of `window.location.href` and intercepted navigation events.)
 *
 * In the browser, use either a <Link> component or the route() method to change routes.
 * The router will also automatically pick up popstate events caused by user-driven browser
 * navigation (forward, back buttons, etc.)
 */
var Router = function (_React$Component) {
    _inherits(Router, _React$Component);

    function Router(props, context) {
        _classCallCheck(this, Router);

        var _this = _possibleConstructorReturn(this, (Router.__proto__ || Object.getPrototypeOf(Router)).call(this, props, context));

        _initialiseProps.call(_this);

        if (!BROWSER && !props.url) {
            throw new Error('props.url is required for non-browser environments');
        }

        var routes = _this.processRoutes(props.routes);
        var url = props.url || Router.getURL();

        _this.state = _this.getStateUpdateForUrl(url, routes);

        props.routerDidInitialize(createRouteContext(_this.state.activeRoute, url));
        return _this;
    }

    /**
     * In a browser setting, we only want to rely on browser navigation events
     * to determine routing updates.
     */


    _createClass(Router, [{
        key: 'shouldRecompute',
        value: function shouldRecompute(nextProps) {
            return nextProps.routes !== this.props.routes || nextProps.url !== this.state.url && !BROWSER;
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.shouldRecompute(nextProps)) {
                this.recomputeRoutingState(BROWSER ? this.state.url : nextProps.url, nextProps.routes);
            }
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            window.addEventListener('popstate', this.handleLocationChange);
            window.addEventListener('hashchange', this.handleLocationChange);
        }
    }, {
        key: 'componentWillUpdate',
        value: function componentWillUpdate() {
            this.recomputeRoutingState;
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            window.removeEventListener('popstate', this.handleLocationChange);
            window.removeEventListener('hashchange', this.handleLocationChange);
        }
    }, {
        key: 'render',
        value: function render() {
            var contextValue = createRouteContext(this.state.activeRoute, this.state.url);

            return React.createElement(
                Provider,
                { value: contextValue },
                React.createElement(
                    this.props.outerComponent,
                    contextValue,
                    this.renderChildren(this.state.children, contextValue)
                )
            );
        }
    }, {
        key: 'renderChildren',
        value: function renderChildren(renderable, routingProps) {
            if (renderable === null) {
                return React.createElement(this.props.loadingComponent, routingProps);
            } else if (!React.isValidElement(renderable)) {
                return React.createElement(renderable, routingProps);
            } else {
                return renderable;
            }
        }
    }, {
        key: 'processChildren',
        value: function processChildren(unknown) {
            if (unknown instanceof Promise) {
                var instance = this;
                instance.promise = unknown;
                unknown.then(function handlePromiseResolution(result) {
                    /**
                     * Is this promise still valid? If not, ignore the
                     * resolution.
                     */
                    if (instance.promise === this) {
                        instance.setState({ children: result });
                        this.promise = null;
                    }
                }.bind(unknown), NOOP);

                return null;
            } else {
                return unknown;
            }
        }
    }, {
        key: 'processRoutes',
        value: function processRoutes(routes) {

            return routes.map(processRoute);
        }
    }, {
        key: 'getStateUpdateForUrl',
        value: function getStateUpdateForUrl(url, routes) {
            var result = findRoute(routes, url);

            return {
                activeRoute: result.route,
                children: this.processChildren(result.route.render(createRouteContext(result.route, result.url))),
                routes: routes,
                url: result.url
            };
        }
    }]);

    return Router;
}(React.Component);

/**
 * Compose it like this:
 *
 * <RoutingState>
 *   {({ location, params, route }) => {
 *      return <div>{location.pathname}</div>
 *   }}
 * </RoutingState>
 */
Router.propTypes = {
    /**
     * Provide a spinner or something to look at while the promise
     * is in flight if using async routes.
     */
    loadingComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),

    /**
     * An optional app runtime component. Think of it like the "shell" of your
     * app, so perhaps the outer container, nav bar, etc. You'll probably want to
     * put any "Provider" type components here that are intended to wrap your
     * whole application.
     */
    outerComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),

    routes: PropTypes.arrayOf(PropTypes.shape({
        /**
         * A RegExp, string, or function accepting the URL as
         * an argument and returning a boolean if valid.
         */
        path: PropTypes.oneOfType([PropTypes.instanceOf(RegExp), PropTypes.string, PropTypes.func]).isRequired,

        /**
         * A string URL path to a different route. If this is given,
         * then "render" is not required.
         */
        redirect: PropTypes.string,

        /**
         * A function that returns one of the following:
         *
         * 1. JSX.
         * 2. A React component class.
         * 3. A promise resolving to JSX or a React component class.
         */
        render: PropTypes.func
    })).isRequired,

    /**
     * A hook for reacting to an impending route transition. Accepts a promise
     * and will pause the route transition until the promise is resolved. Return
     * false or reject a given promise to abort the routing update.
     *
     * Provides currentRouting and nextRouting as arguments.
     */
    routeWillChange: PropTypes.func,

    /**
     * A hook for reacting to a completed route transition. It might be used
     * for synchronizing some global state if desired.
     *
     * Provides currentRouting and previousRouting as arguments.
     */
    routeDidChange: PropTypes.func,

    /**
     * A hook for synchronizing initial routing state.
     *
     * Providers initialRouting as an argument.
     */
    routerDidInitialize: PropTypes.func,

    /**
     * The initial URL to be used for processing, falls back to
     * window.location.href for non-SSR. Required for environments without
     * browser navigation eventing.
     */
    url: PropTypes.string
};
Router.defaultProps = {
    loadingComponent: 'div',
    outerComponent: 'div',
    routeDidChange: NOOP,
    routeWillChange: NOOP,
    routerDidInitialize: NOOP,
    url: ''
};

Router.getURL = function () {
    return window.location.href;
};

var _initialiseProps = function _initialiseProps() {
    var _this4 = this;

    this.noFallbackWarningEmitted = false;
    this.promise = null;

    this.handleLocationChange = function () /* event */{
        var currentValue = createRouteContext(_this4.state.activeRoute, _this4.state.url);

        var _findRoute = findRoute(_this4.state.routes, Router.getURL()),
            nextRoute = _findRoute.route,
            nextUrl = _findRoute.url;

        var nextValue = createRouteContext(nextRoute, nextUrl);
        var result = _this4.props.routeWillChange(currentValue, nextValue);
        var cb = function cb() {
            return _this4.props.routeDidChange(nextValue, currentValue);
        };
        var finish = function finish() {
            return _this4.recomputeRoutingState(nextUrl, _this4.state.routes, cb);
        };

        if (result === false) return;else if (result instanceof Promise) result.then(finish, NOOP);else finish();
    };

    this.recomputeRoutingState = function (url, routes, cb) {
        _this4.setState(_this4.getStateUpdateForUrl(url, routes === _this4.state.routes ? routes : _this4.processRoutes(routes)), cb);
    };
};

var RoutingState = Consumer;

/**
 * A polymorphic anchor link component. On click/tap/enter if the destination
 * matches a value route, the routing context will be modified without
 * reloading the page. Otherwise, it will act like a normal anchor link.
 *
 * If something other than an anchor tag is specified via props.as, a
 * [role="link"] attribute will be added for basic assistive technology support.
 *
 * Adds [data-active] if the given href matches the active route.
 */
var Link = function (_React$PureComponent) {
    _inherits(Link, _React$PureComponent);

    function Link() {
        var _ref;

        var _temp, _this2, _ret;

        _classCallCheck(this, Link);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, (_ref = Link.__proto__ || Object.getPrototypeOf(Link)).call.apply(_ref, [this].concat(args))), _this2), _this2.handleNavigationIntent = function (e) {
            if (e.type !== 'keydown' || e.type === 'keydown' && (e.key === 'Enter' || e.key === 'Space')) {
                e.preventDefault();
                e.stopPropagation();

                if (e.metaKey || e.target.getAttribute('target') === '_blank') {
                    window.open(_this2.props.href);
                } else {
                    route(_this2.props.href);
                }
            }
        }, _temp), _possibleConstructorReturn(_this2, _ret);
    }

    _createClass(Link, [{
        key: 'render',
        value: function render() {
            var _this3 = this;

            return React.createElement(
                Consumer,
                null,
                function (_ref2) {
                    var route$$1 = _ref2.route;

                    return React.createElement(_this3.props.as, Object.assign({}, _this3.props, {
                        'data-active': valid(route$$1.test, _this3.props.href) ? '' : undefined,
                        as: undefined,
                        href: _this3.shouldRenderAnchorProps() ? _this3.props.href : undefined,
                        role: _this3.shouldRenderRole() ? 'link' : undefined,
                        onClick: _this3.handleNavigationIntent,
                        onKeyDown: _this3.handleNavigationIntent,
                        onTouchEnd: _this3.handleNavigationIntent,
                        target: _this3.shouldRenderAnchorProps() ? _this3.props.target : undefined
                    }));
                }
            );
        }
    }, {
        key: 'shouldRenderAnchorProps',
        value: function shouldRenderAnchorProps() {
            return this.props.as === Link.defaultProps.as || typeof this.props.as !== 'string';
        }
    }, {
        key: 'shouldRenderRole',
        value: function shouldRenderRole() {
            return this.props.as !== Link.defaultProps.as;
        }
    }]);

    return Link;
}(React.PureComponent);
Link.propTypes = {
    /**
     * An HTML tag name or valid ReactComponent class to be rendered. Must
     * be compatible with React.createElement.
     *
     * Defaults to an anchor "a" tag.
     */
    as: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),

    /**
     * A valid relative or absolute URL string.
     */
    href: PropTypes.string.isRequired,

    /**
     * Any valid value of the anchor tag "target" attribute.
     *
     * See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-target
     */
    target: PropTypes.string
};
Link.defaultProps = {
    as: 'a'
};

exports.match = match;
exports.route = route;
exports.Router = Router;
exports.RoutingState = RoutingState;
exports.Link = Link;
//# sourceMappingURL=cjs.js.map
